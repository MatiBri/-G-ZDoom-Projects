version 3.5

//CUBO EJEMPLO
//FIN CUBO

Class FemaleScientist : Actor
{
  Default
  {
    obituary "%o was stabbed by a zombie scientist.";
    health 15;
    mass 90;
    speed 10;
    Radius 19;
    Height 52;
    painchance 200;
    seesound "fem/sight";
    painsound "fem/pain";
    deathsound "fem/death";
    activesound "fem/active";
    MONSTER;
    +FLOORCLIP;
  }

  States
  {
   Spawn:
    FSZK AB 10 A_Look();
    loop;
  See:
    FSZK AABBCCDD 4 A_Chase();
    loop;
  Melee:
    FSZK E 4 A_FaceTarget();
    FSZK F 8 A_CustomMeleeAttack (random (1, 5) *5, "KnifeHit", "skeleton/swing");
    FSZK E 4;
    goto See;
  Pain:
    FSZK G 3;
    FSZK G 3 A_Pain();
    goto See;
  Death:
    FSZK H 5;
    FSZK I 5 A_Scream();
    FSZK J 5 A_NoBlocking();
    FSZK K 5;
    FSZK L 5;
    FSZK M 5;
    FSZK N -1;
    stop;
  XDeath:
    FSZK O 5;
    FSZK P 5 A_XScream();
    FSZK Q 5 A_NoBlocking();
    FSZK RSTUV 5;
    FSZK W -1;
    stop;
  Raise:
    FSZK MLKJIH 5;
    goto See;
  }
}


//Script para el clima(Nieve,lluvia,etc)
//version "3.5"


//#include "thirdparty/we4ther_eff3cts/includer.zc"



//CÃ³digo para el HUD personalizado
//version "2.5.0"

Class MinimalStatusBar : BaseStatusBar {
	HUDFont mMM2BigFont;
	HUDFont mMM2SmallFont;
	InventoryBarState diparms;
	Array<Ammo> ownedAmmo;
	int curAmmoIndex;
	
	// not used
	void DrawUnitBarImage(String unit, String overUnit, int monitor, Vector2 pos, int length, int flags = 0) {		
		int healthClamp = (monitor > 100) ? 100 : monitor;
		for (int i = 0; i < healthClamp * length / 100; i++) {
			DrawImage(unit, (pos.x + i, pos.y), DI_ITEM_LEFT | flags);
		}
		int overhealthClamp = (monitor - 100 > 100) ? 100 : monitor - 100;
		for (int i = 0; i < overhealthClamp * length / 100; i++) {
			DrawImage(overUnit, (pos.x + i, pos.y), DI_ITEM_LEFT | flags);
		}
	}
	
	void DrawUnitBarCol(Color unit, Color overUnit, int monitor, Vector2 pos, Vector2 size, int flags = 0) {
		if (monitor <= 0) return;
		int monClamp = (monitor > 100) ? 100 : monitor;
		// fill the "normal" part
		Fill(unit, pos.x, pos.y, monClamp * size.x / 100, size.y, flags);
		int overmonClamp = (monitor - 100 > 100) ? 100 : monitor - 100;
		// fill the "over" part (for bonus health, armor)
		if (overmonClamp > 0) {
			Fill(overunit, pos.x, pos.y, overmonClamp * size.x / 100, size.y, flags);
		}
	}
	
	void DrawUnitBarGrad(Color uF, Color uT, Color ovuF, Color ovuT,
						 int monitor, Vector2 pos, Vector2 size, int flags = 0) {
		
		// get the change in color every iteration
		double uFD[4] = { 0.0, 0.0, 0.0, 0.0 };
		uFD[0] = (uF.a - uT.a) / size.y; uFD[1] = (uF.r - uT.r) / size.y;
		uFD[2] = (uF.g - uT.g) / size.y; uFD[3] = (uF.b - uT.b) / size.y;
		double ovuFD[4] = { 0.0, 0.0, 0.0, 0.0 };
		ovuFD[0] = (ovuF.a - ovuT.a) / size.y; ovuFD[1] = (ovuF.r - ovuT.r) / size.y;
		ovuFD[2] = (ovuF.g - ovuT.g) / size.y; ovuFD[3] = (ovuF.b - ovuT.b) / size.y;
		
		// draw bar, change color, rinse & repeat until done
		Color drawCol = "000000";
		Color overDrawCol = "000000";
		int cC[4] = { 0, 0, 0, 0 };
		int ovcC[4] = { 0, 0, 0, 0 };
		for (int y = 0; y < size.y; y++) {
			drawCol = Color(uF.a + cC[0], uF.r + cC[1], uF.g + cC[2], uF.b + cC[3]);
			overDrawCol = Color(ovuF.a + ovcC[0], ovuF.r + ovcC[1], ovuF.g + ovcC[2], ovuF.b + ovcC[3]);
			DrawUnitBarCol(drawCol, overDrawCol, monitor, (pos.x, pos.y + y), (size.x, 1), flags);
			cC[0] -= uFD[0]; cC[1] -= uFD[1]; cC[2] -= uFD[2]; cC[3] -= uFD[3];
			ovcC[0] -= ovuFD[0]; ovcC[1] -= ovuFD[1]; ovcC[2] -= ovuFD[2]; ovcC[3] -= ovuFD[3];
		}
	}
	
	// makes my life easier
	Vector2 TexSize(String texture) { return Texman.GetScaledSize(TexMan.CheckForTexture(texture, TexMan.Type_Any)); }
	
	// draw the edges of a "hud box"
	Vector2, Vector2, Vector2, Vector2 DrawHUDBoxEdges(String corner, String edge, Vector2 pos, Vector2 size, int flags = 0, double alpha = 1) {
		// corners are ezpz
		DrawImage(corner.."TL", pos, DI_ITEM_LEFT_TOP | flags, alpha);
		DrawImage(corner.."TR", (pos.x + size.x, pos.y), DI_ITEM_RIGHT_TOP | flags, alpha);
		DrawImage(corner.."BL", (pos.x, pos.y + size.y), DI_ITEM_LEFT_BOTTOM | flags, alpha);
		DrawImage(corner.."BR", pos + size, DI_ITEM_RIGHT_BOTTOM | flags, alpha);
		
		// store the sizes of all the corners so we know where to draw the edges
		Vector2 tlCornerSize = TexSize(corner.."TL");
		Vector2 trCornerSize = TexSize(corner.."TR");
		Vector2 blCornerSize = TexSize(corner.."BL");
		Vector2 brCornerSize = TexSize(corner.."BR");
		
		// the edges are drawn as one image, just scaled on the x/y axis
		DrawImage(edge.."T", (pos.x + tlCornerSize.x, pos.y), DI_ITEM_LEFT_TOP | flags,
				  alpha, (-1, -1), (size.x - (tlCornerSize.x + trCornerSize.x), 1));
		DrawImage(edge.."B", (pos.x + blCornerSize.x, pos.y + size.y), DI_ITEM_LEFT_BOTTOM | flags,
				  alpha, (-1, -1), (size.x - (blCornerSize.x + brCornerSize.x), 1));
		
		DrawImage(edge.."L", (pos.x, pos.y + tlCornerSize.y), DI_ITEM_LEFT_TOP | flags,
				  alpha, (-1, -1), (1, size.y - (tlCornerSize.y + blCornerSize.y)));
		DrawImage(edge.."R", (pos.x + size.x, pos.y + blCornerSize.y), DI_ITEM_RIGHT_TOP | flags,
				  alpha, (-1, -1), (1, size.y - (trCornerSize.y + brCornerSize.y)));
		
		return tlCornerSize, trCornerSize, blCornerSize, brCornerSize;
	}
	
	void DrawHudBoxCol(String corner, String edge, Color fillColor, Vector2 pos, Vector2 size, int flags = 0, double alpha = 1) {
		// get the corner sizes
		Vector2 tlCornerSize, trCornerSize, blCornerSize, brCornerSize;
		[tlCornerSize, trCornerSize, blCornerSize, brCornerSize] = DrawHudBoxEdges(corner, edge, pos, size, flags, alpha);
		
		// fill in the inside
		fillColor = Color(int(alpha * fillColor.a), fillColor.r, fillColor.g, fillColor.b);
		Fill(fillColor, pos.x + tlCornerSize.x, pos.y + tlCornerSize.y,
			 size.x - (tlCornerSize.x + trCornerSize.x), size.y - (tlCornerSize.y + blCornerSize.y), flags);
	}

	override void Init() {	
		Super.Init();
		// this has to be done, even if the HUD is fullscreen, it prevents a crash
		SetSize(0, 320, 200);
		
		// Create the font used for the fullscreen HUD
		Font fnt = "MM2FONTO";
		mMM2BigFont = HUDFont.Create(fnt);
		fnt = "MM2SFNTO";
		// the small font is monospace because it helps with centering and positioning
		mMM2SmallFont = HUDFont.Create(fnt, fnt.GetCharWidth("0"), true);
		diparms = InventoryBarState.Create(null, Font.CR_UNTRANSLATED, 1, "ITEMBOX");
	}
	
	override void DrawAutomapHUD(double ticFrac) {
		// This uses the normal automap HUD but just changes the highlight color.
		DoDrawAutomapHUD(Font.CR_GREY, Font.CR_UNTRANSLATED);
	}
	
	override void Draw (int state, double TicFrac) {
		// create the list of owned ammo
		// this only contains ammo that the player has weapons for
		ownedAmmo.Clear();
		// credit to argv on zdf for the following if() {} block - my implementation for this was slow
		// as all fuck, and upon it being brought up, jesus was my original code bad D:
		// this should be far faster
		if (CPlayer) {
			for (let inv = CPlayer.mo.Inv; inv; inv = inv.Inv) {
				// [argv] look through the player pawn's inventory for weapons
				if (inv is "Weapon") {
					// [argv] take each ammo item, and add it to ownedAmmo if not already present
					let ammo = Weapon(inv).Ammo1;
					if (ammo && ownedAmmo.Size() == ownedAmmo.Find(ammo)) {
						ownedAmmo.Push(ammo);
					}
					
					ammo = Weapon(inv).Ammo2;
					if (ammo && ownedAmmo.Size() == ownedAmmo.Find(ammo)) {
						ownedAmmo.Push(ammo);
					}
				}
			}
		}
		
		Super.Draw(state, TicFrac);
		
		if (state == HUD_StatusBar)
		{
			BeginStatusBar();
			DrawMainBar(TicFrac);
		}
		else if (state == HUD_Fullscreen)
		{
			BeginHUD();
			DrawFullScreenStuff(TicFrac);
		}
	}
	
	void DrawMainBar(double TicFrac) {
	}
	
	void DrawFullScreenStuff(double TicFrac) {
		if (CPlayer && !automapactive) {
			// flags used for positioning text
			int tAlign = DI_TEXT_ALIGN_CENTER | DI_SCREEN_CENTER_BOTTOM;
			// alpha setting for the boxes, clamped between 1 and 0 or else everything goes wrong
			double alphaSetting = Clamp(CVar.GetCVar("gzs_boxalpha", CPlayer).GetFloat(), 0, 1);
			
			// current ammo
			DrawHudBoxCol("HBCORN", "HBEDGE", Color(128, 0, 0, 0), (-235, -72), (64, 64), DI_SCREEN_CENTER_BOTTOM, alphaSetting);
			DrawString(mMM2SmallFont, "AMMO", (-203, -64), tAlign);
			Inventory a1, a2;
			[a1, a2] = GetCurrentAmmo();
			// basically:
			// if the weapon only uses a1, only draw a1
			// if the weapon only uses a2, only draw a2 (example: demonsteele weaps)
			// if the weapon uses both, draw a1 and a2 (a2 is drawn in a smaller font)
			if (a1 && a2 == NULL) {
				DrawString(mMM2BigFont, FormatNumber(a1.amount, 0, 4), (-203, -48), tAlign);
			}
			else if (a1 == NULL && a2) {
				DrawString(mMM2BigFont, FormatNumber(a2.amount, 0, 4), (-203, -48), tAlign);
			}
			else if (a1 && a2) {
				DrawString(mMM2BigFont, FormatNumber(a1.amount, 0, 4), (-203, -48), tAlign);
				DrawString(mMM2SmallFont, FormatNumber(a2.amount, 0, 6), (-203, -32), tAlign);
			}
			
			// health
			DrawHudBoxCol("HBCORN", "HBEDGE", Color(128, 0, 0, 0), (-163, -72), (128, 64), DI_SCREEN_CENTER_BOTTOM, alphaSetting);
			DrawString(mMM2SmallFont, "HEALTH", (-99, -64), tAlign);
			DrawString(mMM2BigFont, FormatNumber(CPlayer.health, 0, 9), (-99, -48), tAlign);
			DrawHudBoxCol("SBCORN", "SBEDGE", Color(64, 0, 0, 0), (-150, -25), (102, 10), DI_SCREEN_CENTER_BOTTOM);
			DrawUnitBarGrad(Color(255, 255, 0, 0), Color(255, 64, 0, 0), Color(255, 0, 0, 255), Color(255, 0, 0, 64),
							CPlayer.mo.health, (-149, -24), (100, 8), DI_SCREEN_CENTER_BOTTOM);
			
			// doomguy
			DrawHudBoxCol("HBCORN", "HBEDGE", Color(128, 0, 0, 0), (-27, -72), (54, 64), DI_SCREEN_CENTER_BOTTOM, alphaSetting);
			DrawTexture(GetMugShot(5), (0, -40), DI_ITEM_CENTER | DI_SCREEN_CENTER_BOTTOM, 1, (-1, -1), (1.5, 1.5));
			
			// armor
			DrawHudBoxCol("HBCORN", "HBEDGE", Color(128, 0, 0, 0), (35, -72), (128, 64), DI_SCREEN_CENTER_BOTTOM, alphaSetting);
			DrawString(mMM2SmallFont, "ARMOR", (99, -64), tAlign);
			DrawString(mMM2BigFont, FormatNumber(GetArmorAmount(), 0, 9), (99, -48), tAlign);
			DrawHudBoxCol("SBCORN", "SBEDGE", Color(64, 0, 0, 0), (48, -25), (102, 10), DI_SCREEN_CENTER_BOTTOM);
			DrawUnitBarGrad(Color(255, 0, 255, 0), Color(255, 0, 64, 0), Color(255, 0, 0, 255), Color(255, 0, 0, 64),
							GetArmorAmount(), (49, -24), (100, 8), DI_SCREEN_CENTER_BOTTOM);
			
			// keys
			DrawHudBoxCol("HBCORN", "HBEDGE", Color(128, 0, 0, 0), (171, -72), (64, 64), DI_SCREEN_CENTER_BOTTOM, alphaSetting);
			DrawString(mMM2SmallFont, "KEYS", (203, -64), tAlign);
			
			// this is basically just gzdoom.pk3 code, but i changed the flags, offsets and scale a bit
			// goes through the keys list and just draws whatever is appropriate
			bool locks[6];
			String image;
			for (int i = 0; i < 6; i++) locks[i] = CPlayer.mo.CheckKeys(i + 1, false, true);
			// key 1
			if (locks[1] && locks[4]) image = "STKEYS6";
			else if (locks[1]) image = "STKEYS0";
			else if (locks[4]) image = "STKEYS3";
			DrawImage(image, (191, -44), DI_ITEM_CENTER | DI_SCREEN_CENTER_BOTTOM, 1, (-1, -1), (2, 2));
			// key 2
			if (locks[2] && locks[5]) image = "STKEYS7";
			else if (locks[2]) image = "STKEYS1";
			else if (locks[5]) image = "STKEYS4";
			else image = "";
			DrawImage(image, (203, -24), DI_ITEM_CENTER | DI_SCREEN_CENTER_BOTTOM, 1, (-1, -1), (2, 2));
			// key 3
			if (locks[0] && locks[3]) image = "STKEYS8";
			else if (locks[0]) image = "STKEYS2";
			else if (locks[3]) image = "STKEYS5";
			else image = "";
			DrawImage(image, (215, -44), DI_ITEM_CENTER | DI_SCREEN_CENTER_BOTTOM, 1, (-1, -1), (2, 2));
			
			int invY = -96;
			if (CVar.GetCVar("gzs_ammobar", CPlayer).GetInt()) {
				// ammo pool display
				DrawHudBoxCol("SBCORN", "SBEDGE", Color(96, 0, 0, 0), (-235, -92), (470, 16), DI_SCREEN_CENTER_BOTTOM, alphaSetting);
				// the ammo text actually draws out of its box, this clipping rectangle just makes the overflow invisible
				SetClipRect(-234, -91, 468, 14, DI_SCREEN_CENTER_BOTTOM);
				// figure out what ammo the current weapon is using
				for (int i = 0; i < ownedAmmo.Size(); i++) {
					let a = ownedAmmo[i];
					if (CPlayer.ReadyWeapon) {
						if (CPlayer.ReadyWeapon.Ammo1 == ownedAmmo[i]) {
							curAmmoIndex = i;
							break;
						}
						else if (CPlayer.ReadyWeapon.Ammo1 == NULL &&
								 CPlayer.ReadyWeapon.Ammo2 == ownedAmmo[i]) {
							curAmmoIndex = i;
							break;
						}
					}
				}
				if (ownedAmmo.Size() > 0) {
					let curC = ownedAmmo[curAmmoIndex];
					// get the length of the string of the player's current ammo
					int middleStrWidth = (curC.GetTag().." "..curC.Amount.."/"..curC.MaxAmount).Length();
					// roughly the amount of spaces needed to keep the strings from clipping
					int drawOff = ceil(middleStrWidth / 2.0);
					// two strings - one for the left side of the current ammo, one for the right
					String lDisplayString = "";
					String rDisplayString = "";
					// form the strings
					for (int i = 0; i < ownedAmmo.Size(); i++) {
						let c = ownedAmmo[i];
						if (i > curAmmoIndex) {
							rDisplayString = rDisplayString..(" "..c.GetTag().." "..c.Amount.."/"..c.MaxAmount);
						}
						else if (i < curAmmoIndex) {
							lDisplayString = lDisplayString..(c.GetTag().." "..c.Amount.."/"..c.MaxAmount.." ");
						}
					}
					// add a bunch of spaces to the l and r strings so they don't clip with the main string
					for (int i = 0; i < drawOff; i++) {
						rDisplayString = " "..rDisplayString;
						lDisplayString = lDisplayString.." ";
					}
					// work out which color to use for the main string
					int fontTranslation;
					if (CPlayer.ReadyWeapon) {
						if (CPlayer.ReadyWeapon.Ammo1 == curC) {
							fontTranslation = Font.CR_UNTRANSLATED;
						}
						else if (CPlayer.ReadyWeapon.Ammo1 == NULL &&
								 CPlayer.ReadyWeapon.Ammo2 == curC) {
							fontTranslation = Font.CR_UNTRANSLATED;
						}
						else { fontTranslation = FONT.CR_DARKRED; }
					}
					else { fontTranslation = FONT.CR_DARKRED; }
					DrawString(mMM2SmallFont, curC.GetTag().." "..curC.Amount.."/"..curC.MaxAmount, (0, -88), tAlign, fontTranslation);
					DrawString(mMM2SmallFont, lDisplayString, (0, -88), DI_SCREEN_CENTER_BOTTOM | DI_TEXT_ALIGN_RIGHT, Font.CR_DARKRED);
					DrawString(mMM2SmallFont, rDisplayString, (0, -88), DI_SCREEN_CENTER_BOTTOM, Font.CR_DARKRED);
				}
				// get rid of the clipping rectangle
				ClearClipRect();
			}
			else { invY = -76; }
			
			// inv bar
			if (isInventoryBarVisible()) {
				DrawInventoryBar(diparms, (0, invY), 7, DI_SCREEN_CENTER_BOTTOM | DI_ITEM_HCENTER | DI_ITEM_BOTTOM);
			}
			
			// level stats stuff
			bool secrets = CVar.GetCVar("gzs_stats_secrets", CPlayer).GetInt();
			bool monsters = CVar.GetCVar("gzs_stats_monsters", CPlayer).GetInt();
			bool items = CVar.GetCVar("gzs_stats_items", CPlayer).GetInt();
			bool timer = CVar.GetCVar("gzs_stats_timer", CPlayer).GetInt();
			bool gametimer = CVar.GetCVar("gzs_stats_gametimer", CPlayer).GetInt();
			
			font fnt = "MM2SFNTO";
			int fntHeight = fnt.GetHeight();
			int y = 8;
			if (timer) {
				DrawString(mMM2SmallFont, level.TimeFormatted(), (-8, y), DI_SCREEN_RIGHT_TOP | DI_TEXT_ALIGN_RIGHT);
				y += fntHeight + 1;
			}
			if (gametimer) {
				DrawString(mMM2SmallFont, level.TimeFormatted(true), (-8, y), DI_SCREEN_RIGHT_TOP | DI_TEXT_ALIGN_RIGHT);
				y += fntHeight + 1;
			}
			
			y = 8;
			if (monsters) {
				DrawString(mMM2SmallFont, Stringtable.Localize("$AM_MONSTERS").." "..level.killed_monsters.."/"..level.total_monsters, (8, y));
				y += fntHeight + 1;
			}
			if (secrets) {
				DrawString(mMM2SmallFont, Stringtable.Localize("$AM_SECRETS").." "..level.found_secrets.."/"..level.total_secrets, (8, y));
				y += fntHeight + 1;
			}
			if (items) {
				DrawString(mMM2SmallFont, Stringtable.Localize("$AM_ITEMS").." "..level.found_items.."/"..level.total_items, (8, y));
				y += fntHeight + 1;
			}
			
		}
	}
}